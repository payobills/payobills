import Dexie from 'dexie';
import { graphql } from 'graphql';
import { makeExecutableSchema } from '@graphql-tools/schema';

const db = new Dexie('lite_db');
db.version(1).stores({
    bills: 'id,name,billingDate,payByDate,latePayByDate,isEnabled,createdAt,updatedAt',
    billStatements: 'id,startDate,endDate,notes,amount,isFullyPaid,createdAt,updatedAt,billId',
    payments: 'id,billingPeriodStart,billingPeriodEnd,amount,paidAt,createdAt,updatedAt,billId',
    transactions: 'id,merchant,currency,amount,notes,transactionText,backDateString,parseStatus,backDate,createdAt,updatedAt,paidAt,updatedAtString,billId',
    files: 'id,downloadPath,mimeType,extension,fileName,createdAt,updatedAt,ocrID',
    transactionTags: 'id,title',
});

const typeDefs = `
    schema
      @link(url: "https://specs.apollo.dev/link/v1.0")
      @link(url: "https://specs.apollo.dev/join/v0.3", for: EXECUTION)
    {
      query: Query
      mutation: Mutation
    }

    directive @join__enumValue(graph: join__Graph!) repeatable on ENUM_VALUE

    directive @join__field(graph: join__Graph, requires: join__FieldSet, provides: join__FieldSet, type: String, external: Boolean, override: String, usedOverridden: Boolean) repeatable on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

    directive @join__graph(name: String!, url: String!) on ENUM_VALUE

    directive @join__implements(graph: join__Graph!, interface: String!) repeatable on OBJECT | INTERFACE

    directive @join__type(graph: join__Graph!, key: join__FieldSet, extension: Boolean! = false, resolvable: Boolean! = true, isInterfaceObject: Boolean! = false) repeatable on OBJECT | INTERFACE | UNION | ENUM | INPUT_OBJECT | SCALAR

    directive @join__unionMember(graph: join__Graph!, member: String!) repeatable on UNION

    directive @link(url: String, as: String, for: link__Purpose, import: [link__Import]) repeatable on SCHEMA

    input AddOrUpdateBillStatementDTOInput
      @join__type(graph: BILLS)
    {
      id: String
      startDate: String
      endDate: String
      notes: String!
      amount: Float
      bill: ConnectionDTOInput!
      file: ConnectionDTOInput
      edges: EdgesDTOInput
      isFullyPaid: Boolean
    }

    type Bill
      @join__type(graph: PAYMENTS)
    {
      id: Int!
      name: String!
    }

    type BillConnection
      @join__type(graph: BILLS)
    {
      id: Int!
      name: String!
    }

    type BillDTO
      @join__type(graph: BILLS, key: "id")
      @join__type(graph: BILLS, key: "id")
    {
      id: ID!
      name: String!
      billingDate: Int
      payByDate: Int
      latePayByDate: Int
      payments: [PaymentDTO!]!
      isEnabled: Boolean!
      createdAt: DateTime!
      updatedAt: DateTime!
    }

    input BillSortInput
      @join__type(graph: PAYMENTS)
    {
      id: SortEnumType
      name: SortEnumType
    }

    type BillStatementDTO
      @join__type(graph: BILLS)
    {
      id: String!
      startDate: String
      endDate: String
      notes: String!
      createdAt: DateTime!
      updatedAt: DateTime!
      bill: BillConnection!
      statement: File
      amount: Float
      isFullyPaid: Boolean!
      payments: [TransactionDTO!]!
    }

    type BillStatsDTO
      @join__type(graph: BILLS)
    {
      startDate: DateTime!
      endDate: DateTime!
      stats: [StatDTO!]!
    }

    input ConnectionDTOInput
      @join__type(graph: BILLS)
    {
      id: Int!
    }

    input CreateBillDTOInput
      @join__type(graph: BILLS)
    {
      name: String!
      billingDate: Int
      payByDate: Int
      latePayByDate: Int
    }

    """The DateTime scalar represents an ISO-8601 compliant date time type."""
    scalar DateTime
      @join__type(graph: BILLS)
      @join__type(graph: PAYMENTS)
      @specifiedBy(url: "https://www.graphql-scalars.com/date-time")

    scalar DateTimeISO
      @join__type(graph: FILES)

    input EdgesDTOInput
      @join__type(graph: BILLS)
    {
      paymentIds: [String!]!
    }

    """File Entity to represent a file created on NocoDB"""
    type File
      @join__type(graph: BILLS, key: "id")
      @join__type(graph: FILES, key: "id")
      @join__type(graph: PAYMENTS, key: "id")
    {
      """Unique ID for each file. It is generated by NocoDB."""
      id: ID!
      downloadPath: String @join__field(graph: FILES)
      mimeType: String! @join__field(graph: FILES)
      extension: String! @join__field(graph: FILES)
      fileName: String @join__field(graph: FILES)
      createdAt: DateTimeISO! @join__field(graph: FILES)
      updatedAt: DateTimeISO @join__field(graph: FILES)
      ocrID: ID @join__field(graph: FILES)
    }

    """Input type to filter files"""
    input FilesInput
      @join__type(graph: FILES)
    {
      ids: [ID!]
    }

    """Response type for files query which represents a list of files"""
    type FilesReponse
      @join__type(graph: FILES)
    {
      results: [File!]!
    }

    input IdDTOOfInt64Input
      @join__type(graph: PAYMENTS)
    {
      id: Long!
    }

    scalar join__FieldSet

    enum join__Graph {
      BILLS @join__graph(name: "bills", url: "http://payobills-subgraph-bills.payobills.svc.cluster.local/graphql")
      FILES @join__graph(name: "files", url: "http://payobills-files.payobills.svc.cluster.local/graphql")
      PAYMENTS @join__graph(name: "payments", url: "http://payobills-subgraph-payments.payobills.svc.cluster.local/graphql")
    }

    scalar link__Import

    enum link__Purpose {
      """
      SECURITY features provide metadata necessary to securely resolve fields.
      """
      SECURITY

      """
      EXECUTION features provide metadata necessary for operation execution.
      """
      EXECUTION
    }

    """
    The Long scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1.
    """
    scalar Long
      @join__type(graph: PAYMENTS)

    input MarkPaymentForBillDTOInput
      @join__type(graph: BILLS)
    {
      billPeriodStart: DateTime
      billPeriodEnd: DateTime
      amount: Float
      billId: String!
    }

    type Mutation
      @join__type(graph: BILLS)
      @join__type(graph: PAYMENTS)
    {
      addBill(billDto: CreateBillDTOInput!): BillDTO! @join__field(graph: BILLS)
      markPayment(dto: MarkPaymentForBillDTOInput!): PaymentDTO! @join__field(graph: BILLS)
      addOrUpdateBillStatement(dto: AddOrUpdateBillStatementDTOInput!): BillStatementDTO! @join__field(graph: BILLS)
      setTransactionTags(id: String!, tags: String!): TransactionDTO! @join__field(graph: PAYMENTS) @deprecated(reason: "Use the transactionUpdate mutation instead")
      transactionUpdate(id: String!, updateDTO: TransactionUpdateDTOInput!): TransactionDTO! @join__field(graph: PAYMENTS)
      transactionAdd(input: TransactionAddDTOInput!): TransactionDTO! @join__field(graph: PAYMENTS)
      transactionReceiptsSync(input: TransactionReceiptsSyncInput!): [File!]! @join__field(graph: PAYMENTS)
    }

    """Information about pagination in a connection."""
    type PageInfo
      @join__type(graph: PAYMENTS)
    {
      """
      Indicates whether more edges exist following the set defined by the clients arguments.
      """
      hasNextPage: Boolean!

      """
      Indicates whether more edges exist prior the set defined by the clients arguments.
      """
      hasPreviousPage: Boolean!

      """When paginating backwards, the cursor to continue."""
      startCursor: String

      """When paginating forwards, the cursor to continue."""
      endCursor: String
    }

    type PaymentDTO
      @join__type(graph: BILLS)
    {
      id: String!
      billingPeriod: RangeOfNullableOfDateTime!
      amount: Float
      paidAt: DateTime!
      createdAt: DateTime!
      updatedAt: DateTime!
    }

    type Query
      @join__type(graph: BILLS)
      @join__type(graph: FILES)
      @join__type(graph: PAYMENTS)
    {
      bills: [BillDTO!]! @join__field(graph: BILLS)
      billById(id: String!): BillDTO @join__field(graph: BILLS)
      billStats(year: Int!, month: Int!): BillStatsDTO! @join__field(graph: BILLS)
      billStatements(billId: String!): [BillStatementDTO!]! @join__field(graph: BILLS)
      billStatementById(billStatementId: String!): BillStatementDTO @join__field(graph: BILLS)
      files(input: FilesInput): FilesReponse! @join__field(graph: FILES)
      transactions(
        filters: TransactionFiltersInput

        """Returns the first _n_ elements from the list."""
        first: Int

        """Returns the elements in the list that come after the specified cursor."""
        after: String

        """Returns the last _n_ elements from the list."""
        last: Int

        """
        Returns the elements in the list that come before the specified cursor.
        """
        before: String
        order: [TransactionDTOSortInput!]
      ): TransactionsConnection @join__field(graph: PAYMENTS)
      transactionByID(id: String!): TransactionDTO! @join__field(graph: PAYMENTS)
      transactionsByYearAndMonth(
        year: Int!
        month: Int!

        """Returns the first _n_ elements from the list."""
        first: Int

        """Returns the elements in the list that come after the specified cursor."""
        after: String

        """Returns the last _n_ elements from the list."""
        last: Int

        """
        Returns the elements in the list that come before the specified cursor.
        """
        before: String
        order: [TransactionDTOSortInput!]
      ): TransactionsByYearAndMonthConnection @join__field(graph: PAYMENTS)
      transactionTags: [TransactionTagDTO!]! @join__field(graph: PAYMENTS)
    }

    type RangeOfInt32
      @join__type(graph: BILLS)
    {
      start: Int!
      end: Int!
    }

    type RangeOfNullableOfDateTime
      @join__type(graph: BILLS)
    {
      start: DateTime
      end: DateTime
    }

    enum SortEnumType
      @join__type(graph: PAYMENTS)
    {
      ASC @join__enumValue(graph: PAYMENTS)
      DESC @join__enumValue(graph: PAYMENTS)
    }

    type StatDTO
      @join__type(graph: BILLS)
    {
      type: String!
      billIds: [String!]!
      dateRanges: [RangeOfInt32!]!
    }

    input TransactionAddDTOInput
      @join__type(graph: PAYMENTS)
    {
      transactionText: String!
      parseStatus: String!
      bill: IdDTOOfInt64Input!
      merchant: String!
      amount: Float
      notes: String
    }

    type TransactionDTO
      @join__type(graph: BILLS, key: "id")
      @join__type(graph: PAYMENTS, key: "id")
      @join__type(graph: PAYMENTS, key: "id")
    {
      id: ID!
      merchant: String @join__field(graph: PAYMENTS)
      currency: String @join__field(graph: PAYMENTS)
      amount: Float @join__field(graph: PAYMENTS)
      notes: String! @join__field(graph: PAYMENTS)
      transactionText: String! @join__field(graph: PAYMENTS)
      backDateString: String! @join__field(graph: PAYMENTS)
      parseStatus: String! @join__field(graph: PAYMENTS)
      backDate: DateTime @join__field(graph: PAYMENTS)
      createdAt: DateTime! @join__field(graph: PAYMENTS)
      updatedAt: DateTime! @join__field(graph: PAYMENTS)
      paidAt: DateTime! @join__field(graph: PAYMENTS)
      updatedAtString: String! @join__field(graph: PAYMENTS)
      bill: Bill! @join__field(graph: PAYMENTS)
      receipts: [File!]! @join__field(graph: PAYMENTS)
      tags: [String!]! @join__field(graph: PAYMENTS)
    }

    input TransactionDTOSortInput
      @join__type(graph: PAYMENTS)
    {
      id: SortEnumType
      merchant: SortEnumType
      currency: SortEnumType
      amount: SortEnumType
      notes: SortEnumType
      transactionText: SortEnumType
      backDateString: SortEnumType
      parseStatus: SortEnumType
      backDate: SortEnumType
      createdAt: SortEnumType
      updatedAt: SortEnumType
      paidAt: SortEnumType
      updatedAtString: SortEnumType
      bill: BillSortInput
    }

    input TransactionFiltersInput
      @join__type(graph: PAYMENTS)
    {
      ocrId: String
    }

    input TransactionReceiptsSyncInput
      @join__type(graph: PAYMENTS)
    {
      transactionID: String!
    }

    """A connection to a list of items."""
    type TransactionsByYearAndMonthConnection
      @join__type(graph: PAYMENTS)
    {
      """Information to aid in pagination."""
      pageInfo: PageInfo!

      """A list of edges."""
      edges: [TransactionsByYearAndMonthEdge!]

      """A flattened list of the nodes."""
      nodes: [TransactionDTO!]
    }

    """An edge in a connection."""
    type TransactionsByYearAndMonthEdge
      @join__type(graph: PAYMENTS)
    {
      """A cursor for use in pagination."""
      cursor: String!

      """The item at the end of the edge."""
      node: TransactionDTO!
    }

    """A connection to a list of items."""
    type TransactionsConnection
      @join__type(graph: PAYMENTS)
    {
      """Information to aid in pagination."""
      pageInfo: PageInfo!

      """A list of edges."""
      edges: [TransactionsEdge!]

      """A flattened list of the nodes."""
      nodes: [TransactionDTO!]
    }

    """An edge in a connection."""
    type TransactionsEdge
      @join__type(graph: PAYMENTS)
    {
      """A cursor for use in pagination."""
      cursor: String!

      """The item at the end of the edge."""
      node: TransactionDTO!
    }

    type TransactionTagDTO
      @join__type(graph: PAYMENTS)
    {
      id: String!
      title: String!
    }

    input TransactionUpdateDTOInput
      @join__type(graph: PAYMENTS)
    {
      merchant: String
      currency: String
      amount: Float
      parseStatus: String
      notes: String
      backDateString: String
      backDate: DateTime
    }
`;

const resolvers = {
  Query: {
    todos: async () => await db.table('todos').toArray(),
  },
  Mutation: {
    // addTodo: async (_, { title }) => {
    //   const id = await db.table('todos').add({ title, done: false });
    //   return { id, title, done: false };
    // },
    // toggleTodo: async (_, { id }) => {
    //   const todo = await db.table('todos').get(Number(id));
    //   todo.done = !todo.done;
    //   await db.table('todos').put(todo);
    //   return todo;
    // },
  },
};

export const schema = makeExecutableSchema({ typeDefs, resolvers });

export async function executeLocalGraphQL(source: string, variables?: any) {
  const result = await graphql({ schema, source, variableValues: variables });
  return result.data;
}
